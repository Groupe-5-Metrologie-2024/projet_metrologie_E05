#Modules ---------------------------------------------------------------------------------------------------------------

import csv
import matplotlib.pyplot as plt
import statistics as stat
import scipy
import numpy as np
from scipy.special import kv, iv
import os
import time
from scipy.interpolate import interp1d
from scipy.constants import mu_0
from scipy.constants import epsilon_0
from scipy.integrate import quad
from scipy.special import iv as I
from scipy.special import kv as K
from scipy.optimize import fsolve

#Modification generales

#Nombre de lignes - 1 du fichier de temperature
nombre_lignes_conservees = 10000

#A MODIFIER - CE SONT DES SINUS RANDOM - PAS LES BONS
         
x = np.linspace(0.0001,1,10000)
y_1=np.sin(2*np.pi*10000*x)
y_2=2*np.sin(2*np.pi*10000*x+897325)


#fonctions ---------------------------------------------------------------------------------------------------------------

def ouverture_fichier(nomfichier):
    with open(nomfichier, 'r') as csvfile:
        csvreader = csv.reader(csvfile)
        xc = []
        i = 0
        for row in csvreader:
            xc.append(float(row[1]))
            i += 1
            if i >= 10000:
                break
    return xc

def list_to_csv(input_list, file_name):

    # Obtenir le chemin du dossier actuel
    current_directory = os.getcwd()
    # Combiner le chemin du dossier avec le nom du fichier
    file_path = os.path.join(current_directory, file_name)
    
    with open(file_path, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        for row in input_list:
            writer.writerow([row])

def attendre_fichier(nom_fichier, delai_attente=1):

    while not os.path.exists(nom_fichier):
        print(f"En attente du fichier {nom_fichier}...")
        time.sleep(delai_attente)

def conserver_premieres_lignes(fichier_entree, nombre_lignes_conservees, fichier_sortie):
    # Ouvrir le fichier d'entrée en mode lecture et le fichier de sortie en mode écriture
    with open(fichier_entree, 'r', newline='') as csv_entree, open(fichier_sortie, 'w', newline='') as csv_sortie:
        lecteur_csv = csv.reader(csv_entree)
        ecrivain_csv = csv.writer(csv_sortie)
        
        # Parcourir chaque ligne du fichier CSV
        for indice_ligne, ligne in enumerate(lecteur_csv, start=1):
            # Écrire la ligne dans le fichier de sortie si elle est avant ou à la ligne spécifiée
            if indice_ligne <= nombre_lignes_conservees:
                ecrivain_csv.writerow(ligne)
            else:
                # Si on a atteint la ligne spécifiée, sortir de la boucle
                break

def modifier_virgule_csv(fichier_entree, fichier_sortie):

    with open(fichier_entree, 'r', newline='') as csv_entree, open(fichier_sortie, 'w', newline='') as csv_sortie:
        lecteur_csv = csv.reader(csv_entree)
        ecrivain_csv = csv.writer(csv_sortie)
        
        # Parcourir chaque ligne du fichier CSV
        for ligne in lecteur_csv:
            ligne_modifiee = []
            # Parcourir chaque élément de la ligne
            for element in ligne:
                try:
                    # Tente de convertir l'élément en un nombre
                    nombre = float(element)
                    # Si la conversion réussit, ajoute une virgule devant le nombre
                    ligne_modifiee.append(',' + element)
                except ValueError:
                    # Si la conversion échoue, conserve l'élément tel quel
                    ligne_modifiee.append(element)
            
            # Écrire la ligne modifiée dans le fichier de sortie
            csv_sortie.write(','.join(ligne_modifiee) + '\n')

def supprimer_fichier(fichier):
    try:
        os.remove(fichier)
        print(f"Le fichier {fichier} a été supprimé avec succès.")
    except FileNotFoundError:
        print(f"Le fichier {fichier} n'existe pas.")
    except Exception as e:
        print(f"Une erreur s'est produite lors de la suppression du fichier : {e}")

def supprimer_premiere_ligne(fichier_entree, fichier_sortie):
    lignes_restantes = []
    with open(fichier_entree, 'r', newline='') as csv_entree:
        lecteur_csv = csv.reader(csv_entree)
        # Ignorer la première ligne
        next(lecteur_csv)
        # Collecter les lignes restantes
        for ligne in lecteur_csv:
            lignes_restantes.append(ligne)
    
    # Écrire les lignes restantes dans le fichier de sortie
    with open(fichier_sortie, 'w', newline='') as csv_sortie:
        ecrivain_csv = csv.writer(csv_sortie)
        ecrivain_csv.writerows(lignes_restantes)

def traitement_sinus(sinus) :
    # Générer une liste de valeurs de sinus pour la première fonction
    A = sinus

    T = np.linspace(0,len(A)/10000, len(A))

    # Créer une fonction d'interpolation
    f = interp1d(T, A, kind='cubic')

    # Générer une plage de temps pour évaluer la fonction
    temps_interp = np.linspace(min(T), max(T), 1000)

    # Calculer les valeurs interpolées
    valeurs_interp = f(temps_interp)

    # Calculer la dérivée numérique
    dx = temps_interp[1] - temps_interp[0]
    derivee_interp = np.gradient(valeurs_interp, dx)

    # Trouver les zéros de la dérivée
    zeros_indices = np.where(np.diff(np.sign(derivee_interp)))[0]

    # Afficher les zéros de la dérivée
    zeros_temps = temps_interp[zeros_indices]
    zeros_valeurs = valeurs_interp[zeros_indices]

    return zeros_valeurs,zeros_temps

def phase(output):
    phaseurs = []
    temps_ref = 20
    for i in range(len(output)):
        Valeurs, temps = traitement_sinus(output[i])
        max = [l for l in Valeurs if l>Valeurs[0]]
        min = [l for l in Valeurs if l<Valeurs[0]]
        voltage = sum(max)/len(max)-sum(min)/len(min)
        dephasage = max[temps_ref]
        phaseur = voltage*np.exp(-1j*2*np.pi*10000*dephasage)
        phaseurs.append(phaseur)
    return phaseurs

def f_re(xi,rho):
    gamma = b*(xi**2+1j*omega*mur*mu0/rho-omega**2*mu0*mur*e0*er)**(1/2)
    eta = (xi**2-omega**2*mu0*e0)**(1/2)
    return np.real(np.sinc(xi/2)**2*(mur*eta*b*I(0,eta*b)*I(1,gamma)-gamma*I(1,eta*b)*I(0,gamma))/(mur*eta*b*K(0,eta*b)*I(1,gamma)+gamma*K(1,eta*b)*I(0,gamma))*K(1,eta*a)**2)

def f_im(xi,rho):
    gamma = b*(xi**2+1j*omega*mur*mu0/rho-omega**2*mu0*mur*e0*er)**(1/2)
    eta = (xi**2-omega**2*mu0*e0)**(1/2)
    return np.imag(np.sinc(xi/2)**2*(mur*eta*b*I(0,eta*b)*I(1,gamma)-gamma*I(1,eta*b)*I(0,gamma))/(mur*eta*b*K(0,eta*b)*I(1,gamma)+gamma*K(1,eta*b)*I(0,gamma))*K(1,eta*a)**2)

def delta_R(rho,z):
    return -omega*mu0*a**2*n**2*(quad(f_im, -40,40, args=(rho,))[0])-np.real(z)

def delta_X(rho,z):
    return omega*mu0*a**2*n**2*(quad(f_re, -40,40, args=(rho,))[0])-np.imag(z)

def solve_z(z):
    i=0
    while True:
        x = fsolve(delta_R, [10**(-10+i)],args = (z,))
        y = fsolve(delta_X,x,args = (z,))
        if np.isclose(x,y):
            return x
        else:
            i+=1


#Nom des fichiers ---------------------------------------------------------------------------------------------------------------   

nom_fichier_temperature = "Temperature_fini"             
                                
nom_fichier_resistivite = "Resistivite_fini"             

#Modifications pour les CSV ------------------------------------------------------------------------------------------------------   

fichier_entree = "Temperature"
fichier_entree2 = "Resistivite"
fichier_temportaire = "Temperature_2"
fichier_temportaire2 = "Temperature_3"
fichier_entree_3 = "Resistivite3"

#T
supprimer_premiere_ligne(fichier_entree, fichier_temportaire)
conserver_premieres_lignes(fichier_temportaire, nombre_lignes_conservees, fichier_temportaire2)
modifier_virgule_csv(fichier_temportaire2, nom_fichier_temperature)

#R
conserver_premieres_lignes(fichier_entree2, nombre_lignes_conservees, fichier_entree_3)
modifier_virgule_csv(fichier_entree_3, nom_fichier_resistivite)

#Delete
supprimer_fichier(fichier_temportaire)
supprimer_fichier(fichier_temportaire2)
supprimer_fichier(fichier_entree_3)

# MATHS ----------------------------------------------------------------------------------------------------------------------------    

#impedance
z_vect = phase([y_1,y_2])
z = 327*z_vect[1]/z_vect[0]

#Cuivre
b=1.58*10**(-3)
omega=2*np.pi*100*10**3
mur=1
mu0=mu_0
e0=epsilon_0
er=1
a=10.43*10**(-3)
n=1
rho_approx=820*10**(-9)
rho_f = solve_z(z)[0]

print('')
print('')
print('############################################################################################################################################')
print("WARNING - RESULTAT - DEBUT")
print('')
print('')
print("Impédance est :",z,"Résistivité est : ",rho_f, "Ohm/m^3")
print('')
print('')
print("WARNING - RESULTAT - FIN")
print('############################################################################################################################################')

#Listes graphiques depuis les CSV ---------------------------------------------------------------------------------------------------------------

attendre_fichier(nom_fichier_resistivite)
attendre_fichier(nom_fichier_temperature)

x = ouverture_fichier(nom_fichier_temperature)
y = ouverture_fichier(nom_fichier_resistivite) 

#Generation des graphiques -----------------------------------------------------------------------------------------------------------------------

plt.plot(x, y)  
plt.xlabel('Température')  
plt.ylabel('Résistivité')  
plt.title('Graphique de la résistivite de l\'echantillon en fonction de la temperature')  
plt.grid(True)  
plt.show() 

#-------------------------------------------------------------------------------------------------------------------------------------------------
